<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Chicken World Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #101018;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* –ü–æ–¥—Å–∫–∞–∑–∫–∞ —Å–≤–µ—Ä—Ö—É */
        .hint {
            position: fixed;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            padding: 6px 14px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.55);
            color: #e0f4ff;
            font-size: 13px;
            letter-spacing: 0.02em;
            backdrop-filter: blur(10px);
            z-index: 5;
            border: 1px solid rgba(80, 180, 255, 0.5);
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }

        /* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–∂–æ–π—Å—Ç–∏–∫–∞ (–ø—Ä–∞–≤—ã–π –Ω–∏–∂–Ω–∏–π —É–≥–æ–ª) */
        .joystick-wrapper {
            position: fixed;
            right: 16px;
            bottom: 16px;
            width: 140px;
            height: 140px;
            touch-action: none;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.9;
        }

        .joystick-base {
            position: relative;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #444b, #111d);
            border: 2px solid #3af;
            box-shadow: 0 0 12px #3af8;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .joystick-stick {
            position: absolute;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #8cf, #157);
            box-shadow: 0 0 8px #3af8;
            transform: translate(0, 0);
            transition: transform 80ms linear;
        }

        /* –ö–Ω–æ–ø–∫–∏ —Å–ø—Ä–∞–≤–∞ –æ—Ç –¥–∂–æ–π—Å—Ç–∏–∫–∞ */
        .action-buttons {
            position: fixed;
            right: 170px;
            bottom: 24px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 11;
        }

        .action-buttons button {
            width: 52px;
            height: 52px;
            border-radius: 16px;
            border: 1px solid rgba(90, 160, 255, 0.9);
            background: radial-gradient(circle at 30% 30%, #1b2235, #080b12);
            color: #e8f4ff;
            font-size: 18px;
            font-weight: 600;
            box-shadow: 0 0 10px rgba(0, 120, 255, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .action-buttons button:active {
            transform: scale(0.94);
        }

        #invBtn {
            font-size: 14px;
        }

        /* –ö–Ω–æ–ø–∫–∞ –ø—Ä–∏—Ü–µ–ª–∞ —Å–Ω–∏–∑—É —Å–ª–µ–≤–∞ */
        .build-button {
            position: fixed;
            left: 20px;
            bottom: 24px;
            width: 54px;
            height: 54px;
            border-radius: 18px;
            border: 1px solid rgba(90, 200, 255, 0.9);
            background: radial-gradient(circle at 30% 30%, #1b2235, #05060a);
            color: #e8f4ff;
            font-size: 24px;
            box-shadow: 0 0 10px rgba(0, 180, 255, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 11;
        }

        .build-button:active {
            transform: scale(0.94);
        }
    </style>
</head>
<body>

<canvas id="game"></canvas>

<div class="hint" id="hint"></div>

<!-- –í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –¥–∂–æ–π—Å—Ç–∏–∫ -->
<div class="joystick-wrapper" id="joystickArea">
    <div class="joystick-base" id="joystickBase">
        <div class="joystick-stick" id="joystickStick"></div>
    </div>
</div>

<!-- –ö–Ω–æ–ø–∫–∏ –¥–µ–π—Å—Ç–≤–∏—è –∏ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è -->
<div class="action-buttons">
    <button id="actionBtn">E</button>
    <button id="invBtn">INV</button>
</div>

<!-- –ö–Ω–æ–ø–∫–∞ –ø—Ä–∏—Ü–µ–ª–∞ (—Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ) -->
<button class="build-button" id="buildBtn">üéØ</button>

<script>
(function() {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hintEl = document.getElementById('hint');

    function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ---------- –ú–ò–† ----------
    const world = { width: 10000, height: 10000 };

    // –ö–∞–º–µ—Ä–∞
    const camera = { x: 0, y: 0 };

    // –°–µ—Ç–∫–∞
    const GRID_SIZE = 40;

    // –†–µ–∫–∞
    const river = {
        y: 5000,
        width: 180,
        waveOffset: 0,
        speed: 40
    };
    const bridges = [
        { x1: 2800, x2: 3000 },
        { x1: 4900, x2: 5100 },
        { x1: 7200, x2: 7400 }
    ];

    // –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –∏ —Å—Ç–∞—Ç—ã
    const inventory = {
        wood: 0,
        stone: 0,
        leaves: 0,
        berries: 0
    };

    let inventoryOpen = false;
    let inventoryAnim = 0; // 0..1
    let inventoryTarget = 0;
    const inventorySlots = []; // –¥–ª—è –∫–ª–∏–∫–æ–≤ –ø–æ —Å–ª–æ—Ç–∞–º

    // –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø—Ä–µ–¥–º–µ—Ç –¥–ª—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
    let selectedBuildItem = null; // 'wood' –∏ —Ç.–¥.

    // –°—Ç–∞—Ç—ã (0..1)
    let food = 0.7;
    let water = 0.7;
    let health = 1.0;
    let foodOverTime = 0; // –¥–ª—è –ø–µ—Ä–µ–µ–¥–∞–Ω–∏—è

    // –ö—É—Ä–æ—á–∫–∞
    const chicken = {
        x: world.width / 2,
        y: world.height / 2,
        radius: 20,
        speed: 180
    };

    // –î–≤–∏–∂–µ–Ω–∏–µ
    const moveDir = { x: 0, y: 0 };

    // –°–º–µ—Ä—Ç—å / —Ä–µ—Å—Ç–∞—Ä—Ç
    let gameOver = false;
    let gameOverReason = '';
    let gameOverAnim = 0;
    let gameOverTimer = 0;

    function triggerGameOver(reason) {
        if (gameOver) return;
        gameOver = true;
        gameOverReason = reason;
        gameOverAnim = 0;
        gameOverTimer = 2.5; // —Å–µ–∫—É–Ω–¥—ã –¥–æ —Ä–µ—Å—Ç–∞—Ä—Ç–∞
        showHint('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞...', 1.5);
    }

    function resetGame() {
        // –∑–∞–Ω–æ–≤–æ –≥–µ–Ω–µ—Ä–∏–º –≤—Å—ë
        trees.length = 0;
        bushes.length = 0;
        placedBlocks.length = 0;
        generateWorldObjects();

        chicken.x = world.width / 2;
        chicken.y = world.height / 2;

        inventory.wood = 0;
        inventory.stone = 0;
        inventory.leaves = 0;
        inventory.berries = 0;

        food = 0.7;
        water = 0.7;
        health = 1.0;
        foodOverTime = 0;
        selectedBuildItem = null;

        inventoryOpen = false;
        inventoryAnim = 0;
        inventoryTarget = 0;

        gameOver = false;
        gameOverReason = '';
        gameOverAnim = 0;
        gameOverTimer = 0;

        showHint('–ü—Ä–æ–≤–µ–¥–∏ –ø–∞–ª—å—Ü–µ–º –ø–æ –¥–∂–æ–π—Å—Ç–∏–∫—É, —á—Ç–æ–±—ã –¥–≤–∏–≥–∞—Ç—å—Å—è', 4);
    }

    // ---------- HINT / –ü–û–î–°–ö–ê–ó–ö–ò –° –¢–ê–ô–ü–ò–ù–ì–û–ú ----------
    let hintTextFull = '';
    let hintChar = 0;
    let hintTime = 0;
    let hintVisible = false;

    function showHint(text, duration = 3) {
        if (hintTextFull === text && hintVisible) return;
        hintTextFull = text;
        hintChar = 0;
        hintTime = duration;
        hintVisible = true;
        hintEl.style.opacity = '1';
    }

    function updateHint(dt) {
        if (!hintVisible) {
            hintEl.style.opacity = '0';
            return;
        }
        hintChar += dt * 40; // —Å–∫–æ—Ä–æ—Å—Ç—å –ø–µ—á–∞—Ç–∏
        if (hintChar > hintTextFull.length) hintChar = hintTextFull.length;
        hintEl.textContent = hintTextFull.slice(0, Math.floor(hintChar));
        hintTime -= dt;
        if (hintTime <= 0) {
            hintVisible = false;
        }
    }

    // ---------- –î–ñ–û–ô–°–¢–ò–ö ----------
    const joystickBase = document.getElementById('joystickBase');
    const joystickStick = document.getElementById('joystickStick');

    const joystick = {
        active: false,
        baseCenterX: 0,
        baseCenterY: 0,
        maxDist: 36,
        pointerId: null
    };

    function updateJoystickFromPoint(clientX, clientY) {
        const rect = joystickBase.getBoundingClientRect();
        joystick.baseCenterX = rect.left + rect.width / 2;
        joystick.baseCenterY = rect.top + rect.height / 2;

        const dx = clientX - joystick.baseCenterX;
        const dy = clientY - joystick.baseCenterY;
        const dist = Math.hypot(dx, dy);
        const clampedDist = Math.min(dist, joystick.maxDist);

        let nx = 0, ny = 0;
        if (dist > 0.0001) {
            nx = dx / dist;
            ny = dy / dist;
        }

        const offsetX = nx * clampedDist;
        const offsetY = ny * clampedDist;
        joystickStick.style.transform = `translate(${offsetX}px, ${offsetY}px)`;

        moveDir.x = nx;
        moveDir.y = ny;
    }

    function resetJoystick() {
        joystick.active = false;
        joystick.pointerId = null;
        moveDir.x = 0;
        moveDir.y = 0;
        joystickStick.style.transform = 'translate(0, 0)';
    }

    // Touch
    joystickBase.addEventListener('touchstart', (e) => {
        const t = e.changedTouches[0];
        joystick.active = true;
        joystick.pointerId = t.identifier;
        updateJoystickFromPoint(t.clientX, t.clientY);
    }, { passive: true });

    window.addEventListener('touchmove', (e) => {
        if (!joystick.active) return;
        for (let t of e.changedTouches) {
            if (t.identifier === joystick.pointerId) {
                updateJoystickFromPoint(t.clientX, t.clientY);
                break;
            }
        }
    }, { passive: true });

    window.addEventListener('touchend', (e) => {
        if (!joystick.active) return;
        for (let t of e.changedTouches) {
            if (t.identifier === joystick.pointerId) {
                resetJoystick();
                break;
            }
        }
    }, { passive: true });

    window.addEventListener('touchcancel', (e) => {
        if (!joystick.active) return;
        for (let t of e.changedTouches) {
            if (t.identifier === joystick.pointerId) {
                resetJoystick();
                break;
            }
        }
    }, { passive: true });

    // –ú—ã—à—å
    let mouseDown = false;
    joystickBase.addEventListener('mousedown', (e) => {
        mouseDown = true;
        joystick.active = true;
        joystick.pointerId = 'mouse';
        updateJoystickFromPoint(e.clientX, e.clientY);
    });

    window.addEventListener('mousemove', (e) => {
        if (!mouseDown || joystick.pointerId !== 'mouse') return;
        updateJoystickFromPoint(e.clientX, e.clientY);
    });

    window.addEventListener('mouseup', () => {
        if (joystick.pointerId === 'mouse') {
            mouseDown = false;
            resetJoystick();
        }
    });

    // –ö–Ω–æ–ø–∫–∞ E: —Ä–∞–∑–æ–≤–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏ —É–¥–µ—Ä–∂–∞–Ω–∏–µ
    const actionBtn = document.getElementById('actionBtn');
    let actionHeld = false;

    function handleActionOnce() {
        if (gameOver) return;
        // —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ
        if (buildMode && selectedBuildItem === 'wood' && inventory.wood > 0) {
            placeBuildBlock();
            return;
        }
        // –∑–∞—Ç–µ–º —Ä—É–±–∫–∞ –¥–µ—Ä–µ–≤—å–µ–≤ / —è–≥–æ–¥—ã
        chopTreeOrCollectBerries();
    }

    actionBtn.addEventListener('click', () => {
        handleActionOnce();
    });

    actionBtn.addEventListener('pointerdown', () => {
        actionHeld = true;
    });
    actionBtn.addEventListener('pointerup', () => {
        actionHeld = false;
    });
    actionBtn.addEventListener('pointercancel', () => {
        actionHeld = false;
    });
    actionBtn.addEventListener('pointerleave', () => {
        actionHeld = false;
    });

    // –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ E / I –¥–ª—è —Ç–µ—Å—Ç–∞ –Ω–∞ –ü–ö
    window.addEventListener('keydown', (e) => {
        if (e.key === 'e' || e.key === 'E') {
            handleActionOnce();
            actionHeld = true;
        } else if (e.key === 'i' || e.key === 'I') {
            toggleInventory();
        }
    });
    window.addEventListener('keyup', (e) => {
        if (e.key === 'e' || e.key === 'E') {
            actionHeld = false;
        }
    });

    // –ö–Ω–æ–ø–∫–∞ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
    const invBtn = document.getElementById('invBtn');
    invBtn.addEventListener('click', () => {
        toggleInventory();
    });

    function toggleInventory() {
        inventoryOpen = !inventoryOpen;
        inventoryTarget = inventoryOpen ? 1 : 0;
        showHint(inventoryOpen ? '–ù–∞–∂–º–∏ –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä–µ...' : '', 2);
    }

    // –ö–Ω–æ–ø–∫–∞ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ (–ø—Ä–∏—Ü–µ–ª)
    const buildBtn = document.getElementById('buildBtn');
    let buildMode = false;

    buildBtn.addEventListener('click', () => {
        if (gameOver) return;
        if (!selectedBuildItem) {
            showHint('–í—ã–±–µ—Ä–∏ –±–ª–æ–∫ –¥–µ—Ä–µ–≤–∞ –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä–µ', 3);
            return;
        }
        buildMode = true;
        // —Å—Ç–∞–≤–∏–º –ø–æ —Ü–µ–Ω—Ç—Ä—É –∫–ª–µ—Ç–∫–∏
        chicken.x = Math.round(chicken.x / GRID_SIZE) * GRID_SIZE;
        chicken.y = Math.round(chicken.y / GRID_SIZE) * GRID_SIZE;
        showHint('–ù–∞–∂–º–∏ E, —á—Ç–æ–±—ã –ø–æ—Å—Ç–∞–≤–∏—Ç—å –±–ª–æ–∫', 3);
    });

    // ---------- –û–ë–™–ï–ö–¢–´ –ú–ò–†–ê ----------
    const trees = [];
    const bushes = [];
    const placedBlocks = []; // –ø–æ—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –±–ª–æ–∫–∏ –¥–µ—Ä–µ–≤–∞

    function generateWorldObjects() {
        const treeCount = 450;
        const bushCount = 800;

        function rnd(min, max) {
            return Math.random() * (max - min) + min;
        }

        for (let i = 0; i < treeCount; i++) {
            const size = rnd(60, 90);
            trees.push({
                x: rnd(400, world.width - 400),
                y: rnd(400, world.height - 400),
                size,
                state: 'standing', // 'falling','gone'
                angle: 0,
                fallDir: Math.random() < 0.5 ? -1 : 1,
                fallProgress: 0
            });
        }

        for (let i = 0; i < bushCount; i++) {
            const size = rnd(40, 70);
            bushes.push({
                x: rnd(400, world.width - 400),
                y: rnd(400, world.height - 400),
                size,
                isBerry: Math.random() < 0.25,
                berries: 3
            });
        }
    }
    generateWorldObjects();

    // ---------- –†–ò–°–û–í–ê–ù–ò–ï –î–ï–†–ï–í–ê / –ö–£–°–¢–ê ----------
    function drawTree(t, cam) {
        if (t.state === 'gone') return;
        const px = t.x - cam.x;
        const py = t.y - cam.y;

        const size = t.size;
        const crownW = size;
        const crownH = size * 0.7;
        const trunkW = size * 0.23;
        const trunkH = size * 0.9;

        const trunkX = -trunkW / 2;
        const trunkY = 0;
        const crownX = -crownW / 2;
        const crownY = -crownH - trunkH * 0.1;

        ctx.save();
        ctx.translate(px, py);

        if (t.state === 'falling') {
            ctx.translate(0, trunkH / 2);
            ctx.rotate(t.angle);
            ctx.translate(0, -trunkH / 2);
        }

        // —Ç–µ–Ω—å
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        ctx.beginPath();
        ctx.ellipse(0, trunkH, crownW * 0.5, 10, 0, 0, Math.PI * 2);
        ctx.fill();

        // —Å—Ç–≤–æ–ª - —á—ë—Ä–Ω—ã–π –∫–æ–Ω—Ç—É—Ä
        ctx.fillStyle = '#000000';
        ctx.fillRect(trunkX - 2, trunkY - 2, trunkW + 4, trunkH + 4);
        ctx.fillStyle = '#6b3f26';
        ctx.fillRect(trunkX, trunkY, trunkW, trunkH);

        // –∫—Ä–æ–Ω–∞ - —á—ë—Ä–Ω—ã–π –∫–æ–Ω—Ç—É—Ä
        ctx.fillStyle = '#000000';
        ctx.fillRect(crownX - 2, crownY - 2, crownW + 4, crownH + 4);

        // –±–ª–æ–∫–∏ –ª–∏—Å—Ç–≤—ã
        const block = size * 0.16;
        const cols = 4;
        const rows = 3;
        for (let iy = 0; iy < rows; iy++) {
            for (let ix = 0; ix < cols; ix++) {
                const bx = crownX + ix * block;
                const by = crownY + iy * block;
                const shade = iy === 0 ? '#3a7f39' : (iy === rows - 1 ? '#27572e' : '#2f7033');
                ctx.fillStyle = shade;
                ctx.fillRect(Math.round(bx), Math.round(by), Math.round(block), Math.round(block));
            }
        }

        ctx.restore();
    }

    function drawBush(b, cam) {
        const px = b.x - cam.x;
        const py = b.y - cam.y;

        const w = b.size;
        const h = b.size * 0.6;
        const x = px - w / 2;
        const y = py - h / 2;

        ctx.save();
        // –∫–æ–Ω—Ç—É—Ä
        ctx.fillStyle = '#000000';
        ctx.fillRect(Math.round(x) - 2, Math.round(y) - 2, Math.round(w) + 4, Math.round(h) + 4);

        // –æ—Å–Ω–æ–≤–Ω–∞—è –º–∞—Å—Å–∞
        ctx.fillStyle = '#2c6e35';
        ctx.fillRect(Math.round(x), Math.round(y), Math.round(w), Math.round(h));

        ctx.fillStyle = '#3d8c40';
        ctx.fillRect(Math.round(x + 4), Math.round(y + 4), Math.round(w - 8), Math.round(h - 8));

        // –µ—Å–ª–∏ —è–≥–æ–¥–Ω—ã–π –∫—É—Å—Ç
        if (b.isBerry && b.berries > 0) {
            ctx.fillStyle = '#050507';
            if (b.berries >= 1) ctx.fillRect(Math.round(x + w * 0.2), Math.round(y + h * 0.3), 4, 4);
            if (b.berries >= 2) ctx.fillRect(Math.round(x + w * 0.55), Math.round(y + h * 0.55), 4, 4);
            if (b.berries >= 3) ctx.fillRect(Math.round(x + w * 0.7), Math.round(y + h * 0.2), 4, 4);
        }
        ctx.restore();
    }

    // –ø–æ—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –±–ª–æ–∫–∏
    function drawBlocks(cam) {
        for (let b of placedBlocks) {
            const px = b.x - cam.x;
            const py = b.y - cam.y;
            const size = GRID_SIZE;

            ctx.save();
            ctx.fillStyle = '#000000';
            ctx.fillRect(px - size / 2 - 2, py - size / 2 - 2, size + 4, size + 4);
            ctx.fillStyle = '#6b3f26';
            ctx.fillRect(px - size / 2, py - size / 2, size, size);
            ctx.fillStyle = '#845534';
            ctx.fillRect(px - size / 2 + 4, py - size / 2 + 4, size - 8, size - 8);
            ctx.restore();
        }
    }

    // ---------- –ö–û–õ–õ–ò–ó–ò–ò ----------
    function rectCollide(x, y, w, h, cx, cy, r) {
        const closestX = Math.max(x, Math.min(cx, x + w));
        const closestY = Math.max(y, Math.min(cy, y + h));
        const dx = cx - closestX;
        const dy = cy - closestY;
        return dx * dx + dy * dy < r * r;
    }

    function checkCollision(nx, ny) {
        // –°—Ç–≤–æ–ª—ã –¥–µ—Ä–µ–≤—å–µ–≤
        for (let t of trees) {
            if (t.state === 'gone') continue;
            const size = t.size;
            const trunkW = size * 0.23;
            const trunkH = size * 0.9;
            const x = t.x - trunkW / 2;
            const y = t.y; // –≤–µ—Ä—Ö —Å—Ç–≤–æ–ª–∞
            if (rectCollide(x, y, trunkW, trunkH, nx, ny, chicken.radius * 0.7)) {
                return true;
            }
        }
        // –ö—É—Å—Ç—ã - –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–µ–ø—Ä–æ—Ö–æ–¥–∏–º—ã–µ
        for (let b of bushes) {
            const w = b.size;
            const h = b.size * 0.6;
            const x = b.x - w / 2;
            const y = b.y - h / 2;
            if (rectCollide(x, y, w, h, nx, ny, chicken.radius * 0.7)) {
                return true;
            }
        }
        // –ë–ª–æ–∫–∏
        for (let blk of placedBlocks) {
            const size = GRID_SIZE;
            const x = blk.x - size / 2;
            const y = blk.y - size / 2;
            if (rectCollide(x, y, size, size, nx, ny, chicken.radius * 0.7)) {
                return true;
            }
        }
        return false;
    }

    // ---------- –†–ï–ö–ê ----------
    function drawRiver(cam, dt) {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;

        const screenTop = river.y - river.width / 2 - cam.y;
        const screenBottom = river.y + river.width / 2 - cam.y;

        ctx.save();
        ctx.beginPath();
        ctx.rect(0, screenTop, w, river.width);
        ctx.clip();

        // —Ñ–æ–Ω –≤–æ–¥—ã
        ctx.fillStyle = '#1b4d7a';
        ctx.fillRect(0, screenTop, w, river.width);

        // –∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ "–≤–æ–ª–Ω—ã"
        river.waveOffset += river.speed * dt;
        const waveSize = 20;
        ctx.fillStyle = '#2d7fb5';
        for (let x = -100 + (river.waveOffset % (waveSize * 2)); x < w + 100; x += waveSize * 2) {
            ctx.fillRect(x, screenTop + 12, waveSize, 10);
            ctx.fillRect(x + waveSize, screenTop + river.width - 22, waveSize, 10);
        }

        ctx.restore();

        // —Ç—ë–º–Ω–∞—è –∫–∞–π–º–∞ –ø–æ –±–µ—Ä–µ–≥—É
        ctx.fillStyle = '#0b1c23';
        ctx.fillRect(0, screenTop - 4, w, 4);
        ctx.fillRect(0, screenBottom, w, 4);

        // –ú–æ—Å—Ç—ã
        ctx.fillStyle = '#68452c';
        for (let br of bridges) {
            const x1 = br.x1 - cam.x;
            const width = br.x2 - br.x1;
            ctx.fillRect(x1, screenTop - 2, width, river.width + 4);
            ctx.fillStyle = '#856142';
            ctx.fillRect(x1 + 4, screenTop + 6, width - 8, river.width - 12);
            ctx.fillStyle = '#68452c';
        }
    }

    function isOnBridge(x, y) {
        const top = river.y - river.width / 2;
        const bottom = river.y + river.width / 2;
        if (y < top || y > bottom) return false;
        for (let br of bridges) {
            if (x >= br.x1 && x <= br.x2) return true;
        }
        return false;
    }

    function isInRiver(x, y) {
        const top = river.y - river.width / 2 + 10;
        const bottom = river.y + river.width / 2 - 10;
        return y >= top && y <= bottom && !isOnBridge(x, y);
    }

    function isNearRiverBank(x, y) {
        const top = river.y - river.width / 2;
        const bottom = river.y + river.width / 2;
        const distTop = Math.abs(y - top);
        const distBottom = Math.abs(y - bottom);
        const nearBank = (distTop < 40 || distBottom < 40) && !isInRiver(x, y);
        return nearBank;
    }

    // ---------- –î–ï–ô–°–¢–í–ò–Ø: –†–£–ë–ö–ê / –Ø–ì–û–î–´ / –ü–ò–¢–¨ ----------
    function chopTreeOrCollectBerries() {
        if (gameOver) return;
        const actionRadius = 60;
        // –±–ª–∏–∂–∞–π—à–µ–µ –¥–µ—Ä–µ–≤–æ
        let bestTree = null;
        let bestDist = Infinity;
        for (let t of trees) {
            if (t.state !== 'standing') continue;
            const dx = t.x - chicken.x;
            const dy = t.y - chicken.y;
            const dist = Math.hypot(dx, dy);
            if (dist < actionRadius && dist < bestDist) {
                bestDist = dist;
                bestTree = t;
            }
        }

        if (bestTree) {
            // –∑–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –ø–∞–¥–µ–Ω–∏—è
            bestTree.state = 'falling';
            bestTree.angle = 0;
            bestTree.fallDir = chicken.x < bestTree.x ? 1 : -1;
            bestTree.fallProgress = 0;
            showHint('–î–µ—Ä–µ–≤–æ —Å—Ä—É–±–ª–µ–Ω–æ!', 2);
            inventory.wood += 1;
            return;
        }

        // —è–≥–æ–¥—ã
        let bestBush = null;
        bestDist = Infinity;
        for (let b of bushes) {
            if (!b.isBerry || b.berries <= 0) continue;
            const dx = b.x - chicken.x;
            const dy = b.y - chicken.y;
            const dist = Math.hypot(dx, dy);
            if (dist < actionRadius && dist < bestDist) {
                bestDist = dist;
                bestBush = b;
            }
        }
        if (bestBush) {
            bestBush.berries -= 1;
            inventory.berries += 1;
            showHint('–í—ã —Å–æ–±—Ä–∞–ª–∏ —è–≥–æ–¥—ã', 2);
        }
    }

    function handleContinuousAction(dt) {
        if (gameOver) return;
        // –ø–∏—Ç—å –∏–∑ —Ä–µ–∫–∏
        if (actionHeld && isNearRiverBank(chicken.x, chicken.y)) {
            water += dt * 0.3;
            if (water > 1.1) water = 1.1;
            showHint('–í—ã –ø—å—ë—Ç–µ –≤–æ–¥—É...', 0.4);
        }
    }

    // ---------- –°–¢–†–û–ò–¢–ï–õ–¨–°–¢–í–û ----------
    function placeBuildBlock() {
        const gx = Math.round(chicken.x / GRID_SIZE) * GRID_SIZE;
        const gy = Math.round(chicken.y / GRID_SIZE) * GRID_SIZE;

        // –ø—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ–±—ã –Ω–µ —Å—Ç–∞–≤–∏—Ç—å –≤ —Ä–µ–∫—É
        if (isInRiver(gx, gy)) return;

        placedBlocks.push({ x: gx, y: gy });
        inventory.wood -= 1;
        buildMode = false;
    }

    // ---------- –ò–ù–í–ï–ù–¢–ê–†–¨ / –ö–õ–ò–ö–ò ----------

    // –ª–æ–≤–∏–º –∫–ª–∏–∫–∏ –ø–æ canvas –¥–ª—è —Å–ª–æ—Ç–æ–≤
    canvas.addEventListener('click', (e) => {
        if (!inventoryOpen || inventoryAnim < 0.9) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        for (let slot of inventorySlots) {
            if (x >= slot.x && x <= slot.x + slot.w && y >= slot.y && y <= slot.y + slot.h) {
                if (slot.key === 'berries') {
                    if (inventory.berries > 0) {
                        inventory.berries -= 1;
                        food += 0.2;
                        if (food > 1.1) food = 1.1;
                        showHint('–í—ã —Å—ä–µ–ª–∏ —è–≥–æ–¥—ã', 2);
                    }
                } else if (slot.key === 'wood') {
                    if (inventory.wood > 0) {
                        // –≤—ã–¥–µ–ª—è–µ–º –¥–ª—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
                        selectedBuildItem = selectedBuildItem === 'wood' ? null : 'wood';
                        showHint(selectedBuildItem ? '–¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ —Å—Ç—Ä–æ–∏—Ç—å –±–ª–æ–∫–∏ –¥–µ—Ä–µ–≤–∞' : '–°—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ –æ—Ç–º–µ–Ω–µ–Ω–æ', 2);
                    }
                }
                // –¥—Ä—É–≥–∏–µ —Å–ª–æ—Ç—ã –ø–æ–∫–∞ –±–µ–∑ –¥–µ–π—Å—Ç–≤–∏–π
                break;
            }
        }
    });

    // ---------- –û–¢–†–ò–°–û–í–ö–ê –ú–ò–†–ê / HUD / –ò–ù–í–ï–ù–¢–ê–†–Ø ----------
    function drawWorld(ctx) {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;

        // —Ç—Ä–∞–≤–∞ –∏ –∑–µ–º–ª—è (—Ñ–æ–Ω)
        ctx.fillStyle = '#274322';
        ctx.fillRect(0, 0, w, h);

        // —Å–µ—Ç–∫–∞
        ctx.strokeStyle = 'rgba(40,80,40,0.35)';
        ctx.lineWidth = 1;
        const startX = - (camera.x % GRID_SIZE);
        const startY = - (camera.y % GRID_SIZE);

        for (let x = startX; x < w; x += GRID_SIZE) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, h);
            ctx.stroke();
        }
        for (let y = startY; y < h; y += GRID_SIZE) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(w, y);
            ctx.stroke();
        }

        // —Ä–µ–∫–∞
        drawRiver(camera, globalDt);

        // –¥–µ—Ä–µ–≤—å—è
        for (let t of trees) {
            const px = t.x - camera.x;
            const py = t.y - camera.y;
            if (px < -200 || py < -200 || px > w + 200 || py > h + 200) continue;
            drawTree(t, camera);
        }

        // –∫—É—Å—Ç—ã
        for (let b of bushes) {
            const px = b.x - camera.x;
            const py = b.y - camera.y;
            if (px < -200 || py < -200 || px > w + 200 || py > h + 200) continue;
            drawBush(b, camera);
        }

        // –ø–æ—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –±–ª–æ–∫–∏
        drawBlocks(camera);
    }

    function drawChicken(ctx) {
        const sx = chicken.x - camera.x;
        const sy = chicken.y - camera.y;

        ctx.save();
        ctx.translate(sx, sy);

        // –¢–µ–Ω—å
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        ctx.beginPath();
        ctx.ellipse(0, 18, 20, 8, 0, 0, Math.PI * 2);
        ctx.fill();

        // –¢—É–ª–æ–≤–∏—â–µ
        ctx.fillStyle = '#fff7dd';
        ctx.beginPath();
        ctx.arc(0, 0, chicken.radius, 0, Math.PI * 2);
        ctx.fill();

        // –ì–æ–ª–æ–≤–∞
        ctx.beginPath();
        ctx.arc(0, -14, 14, 0, Math.PI * 2);
        ctx.fillStyle = '#fffaf0';
        ctx.fill();

        // –ì—Ä–µ–±–µ—à–æ–∫
        ctx.fillStyle = '#e53935';
        ctx.beginPath();
        ctx.arc(-5, -26, 5, 0, Math.PI * 2);
        ctx.arc(0, -29, 5, 0, Math.PI * 2);
        ctx.arc(5, -26, 5, 0, Math.PI * 2);
        ctx.fill();

        // –ö–ª—é–≤
        ctx.fillStyle = '#ffb300';
        ctx.beginPath();
        ctx.moveTo(10, -14);
        ctx.lineTo(20, -11);
        ctx.lineTo(10, -8);
        ctx.closePath();
        ctx.fill();

        // –ì–ª–∞–∑
        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.arc(4, -16, 2.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    function drawBar(x, y, width, height, value, label) {
        const v = Math.max(0, Math.min(1, value));
        const filled = width * v;

        // —Ñ–æ–Ω
        ctx.fillStyle = 'rgba(10,15,20,0.9)';
        ctx.fillRect(x, y, width, height);

        // —Ä–∞–º–∫–∞
        ctx.strokeStyle = 'rgba(90,170,230,0.9)';
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 0.5, y + 0.5, width - 1, height - 1);

        // —Ü–≤–µ—Ç –ø–æ–ª–æ—Å—ã
        const isOver = value > 1.0;
        ctx.fillStyle = isOver ? '#e53935' : '#43a047';
        ctx.fillRect(x + 2, y + 2, filled - 4, height - 4);

        // —Ç–µ–∫—Å—Ç
        ctx.fillStyle = '#e8f4ff';
        ctx.font = '11px system-ui';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, x + 6, y + height / 2);
    }

    function drawHUD() {
        const w = canvas.clientWidth;

        // —Ñ–æ–Ω –ø–∞–Ω–µ–ª–∏
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = 'rgba(5,10,15,0.9)';
        ctx.fillRect(8, 8, w - 16, 80);
        ctx.restore();

        ctx.strokeStyle = 'rgba(80,190,255,0.7)';
        ctx.lineWidth = 1;
        ctx.strokeRect(8.5, 8.5, w - 17, 79);

        const barWidth = 180;
        const barHeight = 16;
        const barX = 16;
        let barY = 14;

        drawBar(barX, barY, barWidth, barHeight, food, '–ï–¥–∞');
        barY += barHeight + 6;
        drawBar(barX, barY, barWidth, barHeight, water, '–í–æ–¥–∞');
        barY += barHeight + 6;
        drawBar(barX, barY, barWidth, barHeight, health, '–ó–¥–æ—Ä–æ–≤—å–µ');

        // –º–∏–Ω–∏-–∏–Ω–≤–µ–Ω—Ç–∞—Ä—å —Å–ø—Ä–∞–≤–∞
        const text = `Wood: ${inventory.wood}   Stone: ${inventory.stone}   Leaves: ${inventory.leaves}   Berries: ${inventory.berries}`;
        ctx.fillStyle = '#e8f4ff';
        ctx.font = '12px system-ui';
        ctx.textBaseline = 'top';
        ctx.textAlign = 'right';
        ctx.fillText(text, w - 16, 14);
        ctx.textAlign = 'left';
    }

    function drawInventoryWindow(dt) {
        // –∞–Ω–∏–º–∞—Ü–∏—è
        const speed = 6;
        if (Math.abs(inventoryAnim - inventoryTarget) > 0.001) {
            inventoryAnim += (inventoryTarget - inventoryAnim) * speed * dt;
        }

        if (inventoryAnim <= 0.01) return;

        const w = canvas.clientWidth;
        const h = canvas.clientHeight;

        const alpha = 0.6 * inventoryAnim;
        ctx.save();
        ctx.fillStyle = `rgba(0,0,0,${alpha})`;
        ctx.fillRect(0, 0, w, h);
        ctx.restore();

        const boxW = 280;
        const boxH = 220;
        const x = (w - boxW) / 2;
        const y = (h - boxH) / 2;

        const scale = 0.8 + 0.2 * inventoryAnim;
        ctx.save();
        ctx.translate(w / 2, h / 2);
        ctx.scale(scale, scale);
        ctx.translate(-w / 2, -h / 2);

        ctx.fillStyle = 'rgba(10,18,28,0.98)';
        ctx.fillRect(x, y, boxW, boxH);
        ctx.strokeStyle = 'rgba(100,200,255,0.9)';
        ctx.lineWidth = 2;
        ctx.strokeRect(x + 1, y + 1, boxW - 2, boxH - 2);

        ctx.fillStyle = '#e8f4ff';
        ctx.font = '14px system-ui';
        ctx.textBaseline = 'top';
        ctx.fillText('–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å', x + 12, y + 10);

        // —Å–ª–æ—Ç—ã 2x2
        const slotSize = 64;
        const startX = x + 30;
        const startY = y + 40;
        const gap = 12;

        inventorySlots.length = 0;

        function drawSlot(ix, iy, label, value, key) {
            const sx = startX + ix * (slotSize + gap);
            const sy = startY + iy * (slotSize + gap);

            ctx.fillStyle = 'rgba(15,25,35,0.95)';
            ctx.fillRect(sx, sy, slotSize, slotSize);
            ctx.strokeStyle = 'rgba(90,150,220,0.9)';
            ctx.strokeRect(sx + 0.5, sy + 0.5, slotSize - 1, slotSize - 1);

            ctx.fillStyle = '#e8f4ff';
            ctx.font = '11px system-ui';
            ctx.textBaseline = 'top';
            ctx.fillText(label, sx + 6, sy + 6);

            ctx.font = '12px system-ui';
            ctx.textBaseline = 'bottom';
            ctx.fillText('x' + value, sx + slotSize - 6, sy + slotSize - 6);

            // –≥–∞–ª–æ—á–∫–∞ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –±–ª–æ–∫–∞
            if (key === 'wood' && selectedBuildItem === 'wood') {
                ctx.fillStyle = '#7cf58f';
                ctx.font = '16px system-ui';
                ctx.textBaseline = 'top';
                ctx.fillText('‚úì', sx + slotSize - 18, sy + 4);
            }

            inventorySlots.push({ x: sx, y: sy, w: slotSize, h: slotSize, key });
        }

        drawSlot(0, 0, 'Wood', inventory.wood, 'wood');
        drawSlot(1, 0, 'Stone', inventory.stone, 'stone');
        drawSlot(0, 1, 'Leaves', inventory.leaves, 'leaves');
        drawSlot(1, 1, 'Berries', inventory.berries, 'berries');

        ctx.restore();
    }

    function drawGameOverOverlay(dt) {
        if (!gameOver) return;
        gameOverAnim += dt * 3;
        if (gameOverAnim > 1) gameOverAnim = 1;

        const w = canvas.clientWidth;
        const h = canvas.clientHeight;

        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0, 0, w, h);

        const boxW = 260;
        const boxH = 140;
        const x = (w - boxW) / 2;
        const y = (h - boxH) / 2;
        const scale = 0.7 + 0.3 * gameOverAnim;

        ctx.translate(w / 2, h / 2);
        ctx.scale(scale, scale);
        ctx.translate(-w / 2, -h / 2);

        ctx.fillStyle = 'rgba(25, 10, 18, 0.95)';
        ctx.fillRect(x, y, boxW, boxH);
        ctx.strokeStyle = 'rgba(255,130,150,0.9)';
        ctx.lineWidth = 2;
        ctx.strokeRect(x + 1, y + 1, boxW - 2, boxH - 2);

        ctx.fillStyle = '#ffb3c1';
        ctx.font = '18px system-ui';
        ctx.textBaseline = 'top';
        ctx.textAlign = 'center';
        ctx.fillText('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞', w / 2, y + 20);

        ctx.font = '13px system-ui';
        ctx.fillStyle = '#ffe8f0';
        ctx.fillText(gameOverReason, w / 2, y + 52);

        ctx.font = '11px system-ui';
        ctx.fillStyle = '#f8d8e5';
        ctx.fillText('–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...', w / 2, y + 90);

        ctx.textAlign = 'left';
        ctx.restore();
    }

    // ---------- –õ–û–ì–ò–ö–ê –°–¢–ê–¢–û–í ----------
    function updateStats(dt) {
        if (gameOver) return;

        // –≥–æ–ª–æ–¥ –∏ –∂–∞–∂–¥–∞ —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º
        food -= dt * 0.01;
        water -= dt * 0.015;
        if (food < 0) food = 0;
        if (water < 0) water = 0;

        // –µ—Å–ª–∏ –≥–æ–ª–æ–¥ / –∂–∞–∂–¥–∞ = 0 ‚Üí –∑–¥–æ—Ä–æ–≤—å–µ –ø–∞–¥–∞–µ—Ç
        if (food === 0 || water === 0) {
            health -= dt * 0.1;
        } else if (health < 1.0 && food > 0.5 && water > 0.5) {
            // –ª—ë–≥–∫–∏–π —Ä–µ–≥–µ–Ω, –µ—Å–ª–∏ –≤—Å—ë –æ–∫
            health += dt * 0.02;
        }
        if (health > 1.0) health = 1.0;

        if (health <= 0) {
            triggerGameOver('–í—ã —É–º–µ—Ä–ª–∏ –æ—Ç –≥–æ–ª–æ–¥–∞ –∏ –∂–∞–∂–¥—ã');
        }

        // –ø–µ—Ä–µ–µ–¥–∞–Ω–∏–µ (–µ—Å–ª–∏ –µ–¥–∞ > 1.0)
        if (food > 1.0) {
            foodOverTime += dt;
            if (foodOverTime > 5) {
                triggerGameOver('–ü–µ—Ä–µ–µ–¥–∞–Ω–∏–µ! –ö—É—Ä–∏—Ü–∞ –Ω–µ –≤—ã–¥–µ—Ä–∂–∞–ª–∞');
            }
        } else {
            foodOverTime = 0;
        }
    }

    // ---------- –õ–û–ì–ò–ö–ê –ü–ê–î–ï–ù–ò–Ø –î–ï–†–ï–í–¨–ï–í ----------
    function updateTrees(dt) {
        for (let t of trees) {
            if (t.state === 'falling') {
                t.fallProgress += dt;
                t.angle = t.fallDir * Math.min(Math.PI / 2, t.fallProgress * 2);
                if (t.fallProgress >= 1) {
                    t.state = 'gone';
                }
            }
        }
    }

    // ---------- –õ–£–ü ----------
    let lastTime = performance.now();
    let globalDt = 0;

    resetGame();

    function loop(now) {
        globalDt = (now - lastTime) / 1000;
        if (globalDt > 0.05) globalDt = 0.05;
        lastTime = now;

        const dt = globalDt;

        // –¥–≤–∏–∂–µ–Ω–∏–µ, –µ—Å–ª–∏ –Ω–µ gameOver
        if (!gameOver) {
            if (moveDir.x !== 0 || moveDir.y !== 0) {
                let nx = chicken.x + moveDir.x / (Math.hypot(moveDir.x, moveDir.y) || 1) * chicken.speed * dt;
                let ny = chicken.y + moveDir.y / (Math.hypot(moveDir.x, moveDir.y) || 1) * chicken.speed * dt;

                // –¥–≤–∏–∂–µ–Ω–∏–µ –ø–æ X
                if (!checkCollision(nx, chicken.y)) {
                    chicken.x = nx;
                }
                // –ø–æ Y
                if (!checkCollision(chicken.x, ny)) {
                    chicken.y = ny;
                }

                chicken.x = Math.max(0, Math.min(world.width, chicken.x));
                chicken.y = Math.max(0, Math.min(world.height, chicken.y));
            }

            // –∑–∞—Ç—è–≥–∏–≤–∞–Ω–∏–µ –≤ —Ä–µ–∫—É
            if (isInRiver(chicken.x, chicken.y)) {
                triggerGameOver('–ö—É—Ä–∏—Ü—É —É–Ω–µ—Å–ª–æ —Ç–µ—á–µ–Ω–∏–µ–º');
            }

            // –∞–ø–¥–µ–π—Ç —Å—Ç–∞—Ç—ã, –¥–µ—Ä–µ–≤–æ, –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ
            updateStats(dt);
            updateTrees(dt);
            handleContinuousAction(dt);

            // —Ö–∏–Ω—Ç—ã –ø–æ —Å–∏—Ç—É–∞—Ü–∏–∏
            // —Ä—è–¥–æ–º –¥–µ—Ä–µ–≤–æ
            let nearTree = false;
            for (let t of trees) {
                if (t.state !== 'standing') continue;
                const dist = Math.hypot(t.x - chicken.x, t.y - chicken.y);
                if (dist < 80) { nearTree = true; break; }
            }
            if (nearTree) showHint('–ù–∞–∂–º–∏—Ç–µ E, —á—Ç–æ–±—ã —Å—Ä—É–±–∏—Ç—å –¥–µ—Ä–µ–≤–æ', 1.5);

            // —Ä—è–¥–æ–º —è–≥–æ–¥–Ω—ã–π –∫—É—Å—Ç
            let nearBerry = false;
            for (let b of bushes) {
                if (!b.isBerry || b.berries <= 0) continue;
                const dist = Math.hypot(b.x - chicken.x, b.y - chicken.y);
                if (dist < 70) { nearBerry = true; break; }
            }
            if (nearBerry) showHint('–ù–∞–∂–º–∏—Ç–µ E, —á—Ç–æ–±—ã —Å–æ–±—Ä–∞—Ç—å —è–≥–æ–¥—ã', 1.5);

            // –ø–∏—Ç—å —É —Ä–µ–∫–∏
            if (isNearRiverBank(chicken.x, chicken.y)) {
                showHint('–ó–∞–∂–º–∏—Ç–µ E, —á—Ç–æ–±—ã –ø–∏—Ç—å –≤–æ–¥—É', 1.5);
            }
        } else {
            // —Ç–∞–π–º–µ—Ä –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞
            gameOverTimer -= dt;
            if (gameOverTimer <= 0) {
                resetGame();
            }
        }

        // –∫–∞–º–µ—Ä–∞
        const screenW = canvas.clientWidth;
        const screenH = canvas.clientHeight;
        camera.x = chicken.x - screenW / 2;
        camera.y = chicken.y - screenH / 2;
        camera.x = Math.max(0, Math.min(world.width - screenW, camera.x));
        camera.y = Math.max(0, Math.min(world.height - screenH, camera.y));

        // —Ä–µ–Ω–¥–µ—Ä
        ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
        drawWorld(ctx);
        drawChicken(ctx);
        drawHUD();
        drawInventoryWindow(dt);
        drawGameOverOverlay(dt);
        updateHint(dt);

        requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
})();
</script>

</body>
</html>
